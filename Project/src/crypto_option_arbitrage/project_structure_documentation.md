# üß± Clean Architecture Project Structure
üìÅ Root: `src/crypto_option_arbitrage`

---

## üóÇÔ∏è Layer: Core
üìÇ Path: `core`


## üóÇÔ∏è Layer: Config
üìÇ Path: `core/config`

- **File**: `asset_rules.py`
  - üìç Path: `core/config/asset_rules.py`

```python
from core.entities.enum.enums import AssetClass

# ⁄©ÿßÿ±ŸÖÿ≤ÿØ ŸÖÿπÿßŸÖŸÑÿßÿ™ ÿ®Ÿá ÿØÿ±ÿµÿØ
ASSET_TRANSACTION_FEES = {
    AssetClass.STOCK: 1.5,
    AssetClass.ETF: 0.5,
    AssetClass.LEVERAGE_ETF: 1.0,
    AssetClass.CRYPTO: 0.2,
    AssetClass.COMMODITY: 0.8,
}
```

- **File**: `__init__.py`
  - üìç Path: `core/config/__init__.py`

```python
```

- **File**: `market_rules.py`
  - üìç Path: `core/config/market_rules.py`

```python
from core.entities.enum.enums import Market

# ÿØÿßŸÖŸÜŸá ŸÜŸàÿ≥ÿßŸÜ ŸÖÿ¨ÿßÿ≤ (ÿ®ÿ± ÿ≠ÿ≥ÿ® ÿØÿ±ÿµÿØ)
MARKET_PRICE_LIMITS = {
    Market.TSE_FIRST: 5.0,
    Market.TSE_SECOND: 5.0,
    Market.IFB_FIRST: 5.0,
    Market.IFB_SECOND: 5.0,
    Market.IFB_THIRD: 5.0,
    Market.IFB_INNOVATION: 10.0,
    Market.IFB_BASE_YELLOW: 3.0,
    Market.IFB_BASE_ORANGE: 2.0,
    Market.IFB_BASE_RED: 1.0,
    Market.ENERGY: 7.0,
    Market.COMMODITY: 10.0,
    Market.GLOBAL: 0.0  # ŸÖÿπŸÖŸàŸÑÿßŸã ÿ®ÿØŸàŸÜ ŸÖÿ≠ÿØŸàÿØ€åÿ™ ŸÜŸàÿ≥ÿßŸÜ
}


# ŸÜÿ±ÿÆ ÿ®Ÿáÿ±Ÿá ÿ®ÿØŸàŸÜ ÿ±€åÿ≥⁄© ÿß€åÿ±ÿßŸÜ ÿ®Ÿá ÿµŸàÿ±ÿ™ ÿπÿØÿØ ÿßÿπÿ¥ÿßÿ±€å (ŸÖÿ´ŸÑÿßŸã 20 ÿØÿ±ÿµÿØ = 0.2)
RISK_FREE_RATE = 0.2
```

- **File**: `trading_rules.py`
  - üìç Path: `core/config/trading_rules.py`

```python
from core.entities.enum.enums import AssetClass

# ŸÖÿØÿ™ ÿ≤ŸÖÿßŸÜ ÿ™ÿ≥Ÿà€åŸá ÿ®ÿ±ÿß€å Ÿáÿ± ⁄©ŸÑÿßÿ≥ ÿØÿßÿ±ÿß€å€å (ÿ®Ÿá ÿ±Ÿàÿ≤ ⁄©ÿßÿ±€å)
ASSET_SETTLEMENT_DAYS = {
    AssetClass.STOCK: 2,
    AssetClass.ETF: 2,
    AssetClass.LEVERAGE_ETF: 2,
    AssetClass.CRYPTO: 0,
    AssetClass.COMMODITY: 1,
}

# ÿ≥ÿßÿπÿ™ ŸÖÿπÿßŸÖŸÑÿßÿ™ ÿ®ÿ±ÿß€å Ÿáÿ± ⁄©ŸÑÿßÿ≥ ÿØÿßÿ±ÿß€å€å
ASSET_TRADING_HOURS = {
    AssetClass.STOCK: ("09:00", "12:30"),
    AssetClass.ETF: ("09:00", "15:00"),
    AssetClass.LEVERAGE_ETF: ("09:00", "15:00"),
    AssetClass.CRYPTO: ("00:00", "23:59"),
    AssetClass.COMMODITY: ("10:00", "15:30"),
}
```


## üóÇÔ∏è Layer: Entities
üìÇ Path: `core/entities`


## üóÇÔ∏è Layer: Asset
üìÇ Path: `core/entities/asset`

- **File**: `asset.py`
  - üìç Path: `core/entities/asset/asset.py`

```python
# core/entities/asset.py

from dataclasses import dataclass
from typing import Optional, Tuple
from datetime import datetime, time
from abc import ABC

from core.entities.enum.enums import AssetClass, Market
from core.config.market_rules import MARKET_PRICE_LIMITS
from core.config.asset_rules import ASSET_TRANSACTION_FEES


@dataclass
class AbstractAsset(ABC):
    name: str                            # ŸÜÿßŸÖ ⁄©ÿßŸÖŸÑ ÿØÿßÿ±ÿß€å€å
    symbol: str                          # ŸÜŸÖÿßÿØ (ŸÖÿ´ŸÑÿßŸã BTC €åÿß ŸÅŸàŸÑÿßÿØ)
    isin: Optional[str]                  # ÿ¥ŸÜÿßÿ≥Ÿá ŸÖŸÑ€å ÿØÿßÿ±ÿß€å€å (ÿ®ÿ±ÿß€å ÿ≥ŸáÿßŸÖ/ETF)
    asset_class: AssetClass              # ŸÜŸàÿπ ÿØÿßÿ±ÿß€å€å (ÿ≥ŸáÿßŸÖÿå ⁄©ÿ±€åŸæÿ™Ÿà Ÿà ...)
    market: Market                       # ÿ®ÿßÿ≤ÿßÿ± ŸÖÿ≠ŸÑ ŸÖÿπÿßŸÖŸÑŸá
    last_price: float                    # ÿ¢ÿÆÿ±€åŸÜ ŸÇ€åŸÖÿ™ ŸÖÿπÿßŸÖŸÑŸá ÿ¥ÿØŸá
    close_price: float                   # ŸÇ€åŸÖÿ™ Ÿæÿß€åÿßŸÜ€å ÿ±ÿ≥ŸÖ€å
    previous_price: float                # ŸÇ€åŸÖÿ™ ÿ±Ÿàÿ≤ ⁄Øÿ∞ÿ¥ÿ™Ÿá
    settlement_days: int                # ŸÖÿØÿ™ ÿ≤ŸÖÿßŸÜ ÿ™ÿ≥Ÿà€åŸá (ŸÖÿ´ŸÑÿßŸã 2 ÿ±Ÿàÿ≤)
    trading_hours: Tuple[str, str]      # ÿ≥ÿßÿπÿ™ ŸÖÿ¨ÿßÿ≤ ŸÖÿπÿßŸÖŸÑŸá ÿ®Ÿá ÿµŸàÿ±ÿ™ ('09:00', '12:30')
    ask_price: Optional[float] = None   # ⁄©ŸÖÿ™ÿ±€åŸÜ ŸÇ€åŸÖÿ™ ŸÅÿ±Ÿàÿ¥ ŸÅÿπŸÑ€å
    bid_price: Optional[float] = None   # ÿ®€åÿ¥ÿ™ÿ±€åŸÜ ŸÇ€åŸÖÿ™ ÿÆÿ±€åÿØ ŸÅÿπŸÑ€å

    def get_price_limit(self) -> float:
        """
        ÿØÿßŸÖŸÜŸá ŸÜŸàÿ≥ÿßŸÜ ŸÖÿ¨ÿßÿ≤ ÿ®ÿ±ÿß€å ÿ®ÿßÿ≤ÿßÿ± ÿØÿßÿ±ÿß€å€å (ÿ®ÿ± ÿ≠ÿ≥ÿ® ÿØÿ±ÿµÿØ)
        """
        return MARKET_PRICE_LIMITS.get(self.market, 0.0)

    def get_transaction_fee(self) -> float:
        """
        ⁄©ÿßÿ±ŸÖÿ≤ÿØ ŸÖÿπÿßŸÖŸÑŸá ÿØÿßÿ±ÿß€å€å (ÿ®ÿ± ÿ≠ÿ≥ÿ® ÿØÿ±ÿµÿØ)
        """
        return ASSET_TRANSACTION_FEES.get(self.asset_class, 0.0)

    def is_trading_now(self, current_time: Optional[datetime] = None) -> bool:
        """
        ÿ®ÿ±ÿ±ÿ≥€å ŸÅÿπÿßŸÑ ÿ®ŸàÿØŸÜ ÿ®ÿßÿ≤ÿßÿ± ÿØÿ± ŸÑÿ≠ÿ∏Ÿá ŸÅÿπŸÑ€å
        """
        now = current_time or datetime.now()
        start_str, end_str = self.trading_hours
        start = time.fromisoformat(start_str)
        end = time.fromisoformat(end_str)
        return start <= now.time() <= end

    def has_price_limit_breach(self, current_price: float) -> bool:
        limit_percent = self.get_price_limit()
        if limit_percent == 0.0:
            return False  # ÿ®ÿ±ÿß€å ⁄©ÿ±€åŸæÿ™Ÿà €åÿß ÿØÿßÿ±ÿß€å€å‚ÄåŸáÿß€å ÿ®ÿØŸàŸÜ ŸÖÿ≠ÿØŸàÿØ€åÿ™
        upper_limit = self.close_price * (1 + limit_percent / 100)
        lower_limit = self.close_price * (1 - limit_percent / 100)
        return current_price > upper_limit or current_price < lower_limit


    def get_spread(self) -> Optional[float]:
        """
        ÿßÿÆÿ™ŸÑÿßŸÅ ŸÇ€åŸÖÿ™ ÿÆÿ±€åÿØ Ÿà ŸÅÿ±Ÿàÿ¥ (ask - bid)
        """
        if self.ask_price is not None and self.bid_price is not None:
            return self.ask_price - self.bid_price
        return None

    def is_valid(self) -> bool:
        """
        ÿ®ÿ±ÿ±ÿ≥€å ÿßÿπÿ™ÿ®ÿßÿ± ÿßŸàŸÑ€åŸá ÿØÿßÿ±ÿß€å€å
        """
        return self.last_price > 0 and self.close_price > 0
```

- **File**: `crypto_asset.py`
  - üìç Path: `core/entities/asset/crypto_asset.py`

```python
# core/entities/crypto_asset.py

from core.entities.asset.asset import AbstractAsset
from core.entities.enum.enums import AssetClass, Market
from core.config.trading_rules import ASSET_SETTLEMENT_DAYS, ASSET_TRADING_HOURS


class CryptoAsset(AbstractAsset):
    def __init__(
        self,
        name: str,
        symbol: str,
        market: Market,
        last_price: float,
        close_price: float,
        previous_price: float,
        ask_price: float = None,
        bid_price: float = None
    ):
        asset_class = AssetClass.CRYPTO
        settlement_days = ASSET_SETTLEMENT_DAYS[asset_class]
        trading_hours = ASSET_TRADING_HOURS[asset_class]

        super().__init__(
            name=name,
            symbol=symbol,
            isin=None,
            asset_class=asset_class,
            market=market,
            last_price=last_price,
            close_price=close_price,
            previous_price=previous_price,
            settlement_days=settlement_days,
            trading_hours=trading_hours,
            ask_price=ask_price,
            bid_price=bid_price
        )
```

- **File**: `etf_asset.py`
  - üìç Path: `core/entities/asset/etf_asset.py`

```python
from core.entities.asset.asset import AbstractAsset
from core.entities.enum.enums import AssetClass, Market
from core.config.trading_rules import ASSET_SETTLEMENT_DAYS, ASSET_TRADING_HOURS


class ETFAsset(AbstractAsset):
    def __init__(
        self,
        name: str,
        symbol: str,
        isin: str,
        market: Market,
        last_price: float,
        close_price: float,
        previous_price: float,
        ask_price: float = None,
        bid_price: float = None
    ):
        asset_class = AssetClass.ETF
        settlement_days = ASSET_SETTLEMENT_DAYS[asset_class]
        trading_hours = ASSET_TRADING_HOURS[asset_class]

        super().__init__(
            name=name,
            symbol=symbol,
            isin=isin,
            asset_class=asset_class,
            market=market,
            last_price=last_price,
            close_price=close_price,
            previous_price=previous_price,
            settlement_days=settlement_days,
            trading_hours=trading_hours,
            ask_price=ask_price,
            bid_price=bid_price
        )
```

- **File**: `__init__.py`
  - üìç Path: `core/entities/asset/__init__.py`

```python
```

- **File**: `leverage_etf_asset.py`
  - üìç Path: `core/entities/asset/leverage_etf_asset.py`

```python
# core/entities/leverage_etf_asset.py

from core.entities.asset.asset import AbstractAsset
from core.entities.enum.enums import AssetClass, Market
from core.config.trading_rules import ASSET_SETTLEMENT_DAYS, ASSET_TRADING_HOURS


class LeverageETFAsset(AbstractAsset):
    def __init__(
        self,
        name: str,
        symbol: str,
        isin: str,
        market: Market,
        last_price: float,
        close_price: float,
        previous_price: float,
        ask_price: float = None,
        bid_price: float = None,
        leverage_ratio: float = 2.0  # ŸÜÿ≥ÿ®ÿ™ ÿßŸáÿ±ŸÖ Ÿæ€åÿ¥‚ÄåŸÅÿ±ÿ∂ (ŸÖÿ´ŸÑÿßŸã 2 ÿ®ÿ±ÿßÿ®ÿ±)
    ):
        asset_class = AssetClass.LEVERAGE_ETF
        settlement_days = ASSET_SETTLEMENT_DAYS[asset_class]
        trading_hours = ASSET_TRADING_HOURS[asset_class]

        super().__init__(
            name=name,
            symbol=symbol,
            isin=isin,
            asset_class=asset_class,
            market=market,
            last_price=last_price,
            close_price=close_price,
            previous_price=previous_price,
            settlement_days=settlement_days,
            trading_hours=trading_hours,
            ask_price=ask_price,
            bid_price=bid_price
        )
```

- **File**: `stock_asset.py`
  - üìç Path: `core/entities/asset/stock_asset.py`

```python
# core/entities/stock_asset.py

from core.entities.asset.asset import AbstractAsset
from core.entities.enum.enums import AssetClass, Market
from core.config.trading_rules import ASSET_SETTLEMENT_DAYS, ASSET_TRADING_HOURS


class StockAsset(AbstractAsset):
    def __init__(
        self,
        name: str,
        symbol: str,
        isin: str,
        market: Market,
        last_price: float,
        close_price: float,
        previous_price: float,
        ask_price: float = None,
        bid_price: float = None
    ):
        asset_class = AssetClass.STOCK
        settlement_days = ASSET_SETTLEMENT_DAYS[asset_class]
        trading_hours = ASSET_TRADING_HOURS[asset_class]

        super().__init__(
            name=name,
            symbol=symbol,
            isin=isin,
            asset_class=asset_class,
            market=market,
            last_price=last_price,
            close_price=close_price,
            previous_price=previous_price,
            settlement_days=settlement_days,
            trading_hours=trading_hours,
            ask_price=ask_price,
            bid_price=bid_price
        )
```


## üóÇÔ∏è Layer: Enum
üìÇ Path: `core/entities/enum`

- **File**: `enums.py`
  - üìç Path: `core/entities/enum/enums.py`

```python
# core/entities/enums.py

from enum import Enum


class AssetClass(str, Enum):
    STOCK = "Stock"
    ETF = "ETF"
    LEVERAGE_ETF = "Leveraged ETF"
    CRYPTO = "Crypto"
    COMMODITY = "Commodity"


class Market(str, Enum):
    #
    # ÿ®Ÿàÿ±ÿ≥ ÿßŸàÿ±ÿßŸÇ ÿ®ŸáÿßÿØÿßÿ± ÿ™Ÿáÿ±ÿßŸÜ (TSE)
    #
    TSE_FIRST = "ÿ®Ÿàÿ±ÿ≥ - ÿ®ÿßÿ≤ÿßÿ± ÿßŸàŸÑ"
    TSE_SECOND = "ÿ®Ÿàÿ±ÿ≥ - ÿ®ÿßÿ≤ÿßÿ± ÿØŸàŸÖ"
    #
    # ŸÅÿ±ÿßÿ®Ÿàÿ±ÿ≥ ÿß€åÿ±ÿßŸÜ (IFB)
    #
    IFB_FIRST = "ŸÅÿ±ÿßÿ®Ÿàÿ±ÿ≥ - ÿ®ÿßÿ≤ÿßÿ± ÿßŸàŸÑ"
    IFB_SECOND = "ŸÅÿ±ÿßÿ®Ÿàÿ±ÿ≥ - ÿ®ÿßÿ≤ÿßÿ± ÿØŸàŸÖ"
    IFB_THIRD = "ŸÅÿ±ÿßÿ®Ÿàÿ±ÿ≥ - ÿ®ÿßÿ≤ÿßÿ± ÿ≥ŸàŸÖ"
    IFB_INNOVATION = "ŸÅÿ±ÿßÿ®Ÿàÿ±ÿ≥ - ÿßÿ®ÿ≤ÿßÿ±Ÿáÿß€å ŸÜŸà€åŸÜ ŸÖÿßŸÑ€å"

    #
    # ÿ®ÿßÿ≤ÿßÿ± Ÿæÿß€åŸá ŸÅÿ±ÿßÿ®Ÿàÿ±ÿ≥
    #

    IFB_BASE_YELLOW = "ÿ®ÿßÿ≤ÿßÿ± Ÿæÿß€åŸá - ÿ≤ÿ±ÿØ"
    IFB_BASE_ORANGE = "ÿ®ÿßÿ≤ÿßÿ± Ÿæÿß€åŸá - ŸÜÿßÿ±ŸÜÿ¨€å"
    IFB_BASE_RED = "ÿ®ÿßÿ≤ÿßÿ± Ÿæÿß€åŸá - ŸÇÿ±ŸÖÿ≤"

    #
    # ÿ≥ÿß€åÿ± ÿ®ÿßÿ≤ÿßÿ±Ÿáÿß€å ÿ±ÿ≥ŸÖ€å ÿß€åÿ±ÿßŸÜ
    #

    ENERGY = "ÿ®Ÿàÿ±ÿ≥ ÿßŸÜÿ±⁄ò€å"
    COMMODITY = "ÿ®Ÿàÿ±ÿ≥ ⁄©ÿßŸÑÿß"
    
    #
    # ÿ®ÿßÿ≤ÿßÿ± ÿ¨ŸáÿßŸÜ€å
    #
    
    GLOBAL = "ÿ®ÿßÿ≤ÿßÿ± ÿ¨ŸáÿßŸÜ€å (⁄©ÿ±€åŸæÿ™Ÿà / ÿÆÿßÿ±ÿ¨€å)"
    
class ContractStatus(str, Enum):
    IN_THE_MONEY = "In the money"
    OUT_OF_THE_MONEY = "Out of the money"
    AT_THE_MONEY = "At the money"
    
class OptionType(Enum):
    CALL = "Call"
    PUT = "Put"```

- **File**: `__init__.py`
  - üìç Path: `core/entities/enum/__init__.py`

```python
```

- **File**: `__init__.py`
  - üìç Path: `core/entities/__init__.py`

```python
```


## üóÇÔ∏è Layer: Option
üìÇ Path: `core/entities/option`


## üóÇÔ∏è Layer: Calculators
üìÇ Path: `core/entities/option/calculators`


## üóÇÔ∏è Layer: Greeks
üìÇ Path: `core/entities/option/calculators/greeks`

- **File**: `base.py`
  - üìç Path: `core/entities/option/calculators/greeks/base.py`

```python
from abc import ABC, abstractmethod
from core.entities.option.value_objects.greeks import OptionGreeks
from core.entities.enum.enums import OptionType

class BaseGreekCalculator(ABC):
    @abstractmethod
    def calculate(
        self,
        option_type: OptionType,
        spot: float,
        strike: float,
        time_to_expiry: float,
        risk_free_rate: float,
        volatility: float
    ) -> OptionGreeks:
        pass
```

- **File**: `black_scholes.py`
  - üìç Path: `core/entities/option/calculators/greeks/black_scholes.py`

```python
from math import exp, log, sqrt
from scipy.stats import norm
from core.entities.enum.enums import OptionType
from core.entities.option.value_objects.greeks import OptionGreeks
from core.entities.option.calculators.greeks.base import BaseGreekCalculator

class BlackScholesGreekCalculator(BaseGreekCalculator):
    def calculate(self, option_type, spot, strike, time_to_expiry, risk_free_rate, volatility) -> OptionGreeks:
        d1 = (log(spot / strike) + (risk_free_rate + 0.5 * volatility ** 2) * time_to_expiry) / (volatility * sqrt(time_to_expiry))
        d2 = d1 - volatility * sqrt(time_to_expiry)

        if option_type == OptionType.CALL:
            delta = norm.cdf(d1)
            theta = (-spot * norm.pdf(d1) * volatility / (2 * sqrt(time_to_expiry))
                     - risk_free_rate * strike * exp(-risk_free_rate * time_to_expiry) * norm.cdf(d2))
            rho = strike * time_to_expiry * exp(-risk_free_rate * time_to_expiry) * norm.cdf(d2)
        else:
            delta = -norm.cdf(-d1)
            theta = (-spot * norm.pdf(d1) * volatility / (2 * sqrt(time_to_expiry))
                     + risk_free_rate * strike * exp(-risk_free_rate * time_to_expiry) * norm.cdf(-d2))
            rho = -strike * time_to_expiry * exp(-risk_free_rate * time_to_expiry) * norm.cdf(-d2)

        gamma = norm.pdf(d1) / (spot * volatility * sqrt(time_to_expiry))
        vega = spot * norm.pdf(d1) * sqrt(time_to_expiry)

        return OptionGreeks(
            delta=delta,
            gamma=gamma,
            theta=theta / 365,  # ÿ™ÿ®ÿØ€åŸÑ ÿ®Ÿá ÿ±Ÿàÿ≤
            vega=vega / 100,
            rho=rho / 100
        )
```

- **File**: `etf_option.py`
  - üìç Path: `core/entities/option/etf_option.py`

```python
# core/entities/option/etf_option.py

from dataclasses import dataclass
from datetime import datetime
from typing import Optional

from core.entities.option.option import AbstractOption
from core.entities.asset.etf_asset import ETFAsset
from core.entities.enum.enums import OptionType


@dataclass
class ETFOption(AbstractOption):
    underlying_asset: ETFAsset
    benchmark_index: Optional[str] = None  # ŸÖÿ´ŸÑÿßŸã "S&P 500", "ÿ¥ÿßÿÆÿµ ŸáŸÖ‚ÄåŸàÿ≤ŸÜ"
    nav_deviation: Optional[float] = None  # ÿßÿÆÿ™ŸÑÿßŸÅ ŸÇ€åŸÖÿ™ ÿ®ÿßÿ≤ÿßÿ± ÿ®ÿß NAV

    def calculate_raw_payoff(self, spot_price: float) -> float:
        if self.option_type == OptionType.CALL:
            return max(0.0, spot_price - self.strike_price)
        return max(0.0, self.strike_price - spot_price)

    def get_payoff(self, spot_price: Optional[float] = None) -> float:
        spot = spot_price or self.spot_price
        raw_payoff_per_unit = self.calculate_raw_payoff(spot)

        # ‚úÖ Ÿáÿ≤€åŸÜŸá‚ÄåŸáÿß ÿ®ÿ±ÿß€å €å⁄© Ÿàÿßÿ≠ÿØ
        fee_per_unit = (self.transaction_fee / 100 * spot) if self.transaction_fee else 0
        settle_per_unit = (self.settlement_cost / 100 * spot) if self.settlement_cost else 0



        total_cost_per_unit = self.premium + fee_per_unit + settle_per_unit
        return (raw_payoff_per_unit - total_cost_per_unit) * self.contract_size

    def get_break_even_price(self) -> float:
        fee = (self.transaction_fee / 100 * self.strike_price) if self.transaction_fee else 0
        settle = (self.settlement_cost / 100 * self.strike_price) if self.settlement_cost else 0
        return self.strike_price + self.premium + fee + settle


    def is_liquid(self) -> bool:
        """
        ÿ®ÿ±ÿ±ÿ≥€å ŸÜŸÇÿØÿ¥ŸàŸÜÿØ⁄Ø€å: ÿß⁄Øÿ± ÿßÿ≥Ÿæÿ±ÿØ ÿÆ€åŸÑ€å ÿ≤€åÿßÿØ ÿ®ÿßÿ¥ÿØÿå ŸÜŸÇÿØÿ¥ŸàŸÜÿØ⁄Ø€å Ÿæÿß€å€åŸÜ ÿßÿ≥ÿ™.
        """
        spread = self.underlying_asset.get_spread()
        if spread is None:
            return False
        return spread / self.underlying_asset.last_price < 0.02  # ⁄©ŸÖÿ™ÿ± ÿßÿ≤ €≤Ÿ™

    def has_nav_deviation(self, nav_price: float) -> bool:
        """
        ÿ®ÿ±ÿ±ÿ≥€å ÿßŸÜÿ≠ÿ±ÿßŸÅ ŸÇ€åŸÖÿ™ ŸÜÿ≥ÿ®ÿ™ ÿ®Ÿá NAV
        """
        deviation = abs(self.spot_price - nav_price) / nav_price
        self.nav_deviation = deviation
        return deviation > 0.03  # ÿ®€åÿ¥ÿ™ÿ± ÿßÿ≤ €≥Ÿ™
```

- **File**: `__init__.py`
  - üìç Path: `core/entities/option/__init__.py`

```python
```

- **File**: `leverage_etf_option.py`
  - üìç Path: `core/entities/option/leverage_etf_option.py`

```python
from dataclasses import dataclass
from typing import Optional
from core.entities.option.option import AbstractOption
from core.entities.asset.leverage_etf_asset import LeverageETFAsset
from core.entities.enum.enums import OptionType


@dataclass
class LeverageETFOption(AbstractOption):
    underlying_asset: LeverageETFAsset
    leverage_ratio: Optional[float] = 2.0  # ÿßŸáÿ±ŸÖ Ÿæ€åÿ¥‚ÄåŸÅÿ±ÿ∂

    def calculate_raw_payoff(self, spot_price: float) -> float:
        if self.option_type == OptionType.CALL:
            return max(0.0, (spot_price - self.strike_price) * self.leverage_ratio)
        return max(0.0, (self.strike_price - spot_price) * self.leverage_ratio)

    def get_payoff(self, spot_price: Optional[float] = None) -> float:
        spot = spot_price or self.spot_price
        raw_payoff_per_unit = self.calculate_raw_payoff(spot)

        fee_per_unit = (self.transaction_fee / 100 * spot) if self.transaction_fee else 0
        settle_per_unit = (self.settlement_cost / 100 * spot) if self.settlement_cost else 0

        total_cost_per_unit = self.premium + fee_per_unit + settle_per_unit
        return (raw_payoff_per_unit - total_cost_per_unit) * self.contract_size

    def get_break_even_price(self) -> float:
        fee = (self.transaction_fee / 100 * self.strike_price) if self.transaction_fee else 0
        settle = (self.settlement_cost / 100 * self.strike_price) if self.settlement_cost else 0
        return self.strike_price + self.premium + fee + settle

    def get_max_loss(self) -> float:
        """ÿ≠ÿØÿß⁄©ÿ´ÿ± ÿ≤€åÿßŸÜ = ⁄©ŸÑ Ÿáÿ≤€åŸÜŸá Ÿæÿ±ÿØÿßÿÆÿ™€å ÿ®ÿ±ÿß€å ŸÇÿ±ÿßÿ±ÿØÿßÿØ"""
        spot = self.spot_price or self.strike_price
        fee = (self.transaction_fee / 100 * spot) if self.transaction_fee else 0
        settle = (self.settlement_cost / 100 * spot) if self.settlement_cost else 0
        total_cost_per_unit = self.premium + fee + settle
        return total_cost_per_unit * self.contract_size

    def get_max_gain(self, max_spot: float = None) -> Optional[float]:
        """
        ÿ≠ÿØÿß⁄©ÿ´ÿ± ÿ≥ŸàÿØ = (ÿ≥ŸÇŸÅ ŸÇ€åŸÖÿ™ ÿ®ÿßÿ≤ÿßÿ± - ŸÇ€åŸÖÿ™ ÿßÿπŸÖÿßŸÑ) √ó ÿßŸáÿ±ŸÖ √ó contract_size - Ÿáÿ≤€åŸÜŸá ⁄©ŸÑ
        ÿØÿ± ÿµŸàÿ±ÿ™ ŸÜÿ®ŸàÿØ ÿ≥ŸÇŸÅ ŸÇ€åŸÖÿ™ÿå ŸÖŸÇÿØÿßÿ± None ÿ®ÿ±ŸÖ€å‚Äå⁄Øÿ±ÿØÿßŸÜÿØ
        """
        if self.option_type == OptionType.CALL and max_spot:
            raw = max(0, (max_spot - self.strike_price) * self.leverage_ratio)
            return raw * self.contract_size - self.get_max_loss()
        if self.option_type == OptionType.PUT and max_spot:
            raw = max(0, (self.strike_price - max_spot) * self.leverage_ratio)
            return raw * self.contract_size - self.get_max_loss()
        return None
```

- **File**: `option.py`
  - üìç Path: `core/entities/option/option.py`

```python
from abc import ABC, abstractmethod
from dataclasses import dataclass
from datetime import datetime
from typing import Optional
from math import ceil
from core.config.market_rules import RISK_FREE_RATE

from core.entities.enum.enums import OptionType, ContractStatus
from core.entities.asset.asset import AbstractAsset
from core.entities.option.calculators.greeks.black_scholes import BlackScholesGreekCalculator
from core.entities.option.value_objects.greeks import OptionGreeks
from core.entities.option.calculators.greeks.base import BaseGreekCalculator


@dataclass
class AbstractOption(ABC):
    contract_name: str
    option_type: OptionType
    strike_price: float
    premium: float
    expiry: datetime
    underlying_asset: AbstractAsset
    ask: Optional[float] = None
    bid: Optional[float] = None
    contract_size: int = 1000  # ÿ≠ÿ¨ŸÖ Ÿáÿ± ŸÇÿ±ÿßÿ±ÿØÿßÿØ
    transaction_fee: Optional[float] = None  # ÿØÿ±ÿµÿØ
    settlement_cost: Optional[float] = None  # ÿØÿ±ÿµÿØ €åÿß ÿπÿØÿØ€å ÿ´ÿßÿ®ÿ™ ÿ®ÿ≥ÿ™Ÿá ÿ®Ÿá ÿ®ÿßÿ≤ÿßÿ±


    @property
    def time_to_expiry_days(self) -> int:
        """ŸÖÿØÿ™ ÿ≤ŸÖÿßŸÜ ÿ™ÿß ÿ≥ÿ±ÿ±ÿ≥€åÿØ (ÿ®ÿ±ÿ≠ÿ≥ÿ® ÿ±Ÿàÿ≤ÿå ⁄Øÿ±ÿØ ÿ¥ÿØŸá ÿ®Ÿá ÿ®ÿßŸÑÿß)"""
        delta = self.expiry - datetime.utcnow()
        return max(ceil(delta.total_seconds() / 86400), 0)


    @property
    def spot_price(self) -> float:
        """ŸÇ€åŸÖÿ™ ŸÑÿ≠ÿ∏Ÿá‚Äåÿß€å ÿØÿßÿ±ÿß€å€å Ÿæÿß€åŸá"""
        return self.underlying_asset.last_price

    @property
    def contract_status(self) -> ContractStatus:
        """Ÿàÿ∂ÿπ€åÿ™ ŸÇÿ±ÿßÿ±ÿØÿßÿØ: ÿ≥ŸàÿØ/ÿ≤€åÿßŸÜ/ÿ®€å‚Äåÿ™ŸÅÿßŸàÿ™"""
        if self.is_in_the_money():
            return ContractStatus.IN_THE_MONEY
        elif self.is_out_of_the_money():
            return ContractStatus.OUT_OF_THE_MONEY
        return ContractStatus.AT_THE_MONEY

    def is_in_the_money(self) -> bool:
        if self.option_type == OptionType.CALL:
            return self.spot_price > self.strike_price
        return self.spot_price < self.strike_price

    def is_out_of_the_money(self) -> bool:
        if self.option_type == OptionType.CALL:
            return self.spot_price < self.strike_price
        return self.spot_price > self.strike_price

    def is_at_the_money(self) -> bool:
        return self.spot_price == self.strike_price

    def has_expired(self, now: Optional[datetime] = None) -> bool:
        now = now or datetime.utcnow()
        return now >= self.expiry

    def is_valid(self) -> bool:
        return (
            self.strike_price > 0 and
            self.premium >= 0 and
            self.expiry > datetime.utcnow() and
            isinstance(self.underlying_asset, AbstractAsset)
        )
        
    def get_greeks(
        self,
        calculator: BaseGreekCalculator = BlackScholesGreekCalculator(),
        risk_free_rate: float = RISK_FREE_RATE,
        volatility: float = 0.3
    ) -> OptionGreeks:
        """
        ŸÖÿ≠ÿßÿ≥ÿ®Ÿá GreekŸáÿß ÿ®ÿß ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿßÿ≤ ŸÖÿØŸÑ ŸÖÿ¥ÿÆÿµ ÿ¥ÿØŸá
        Ÿæÿßÿ±ÿßŸÖÿ™ÿ±Ÿáÿß:
        - calculator: ÿ¥€åÿ° ŸÖÿ≠ÿßÿ≥ÿ®Ÿá‚Äå⁄Øÿ± ÿßÿ≤ ⁄©ŸÑÿßÿ≥ GreekCalculator (ŸÖÿßŸÜŸÜÿØ BlackScholesGreekCalculator)
        - risk_free_rate: ŸÜÿ±ÿÆ ÿ®Ÿáÿ±Ÿá ÿ®ÿØŸàŸÜ ÿ±€åÿ≥⁄© (Ÿæ€åÿ¥‚ÄåŸÅÿ±ÿ∂ ÿßÿ≤ ⁄©ÿßŸÜŸÅ€å⁄Ø)
        - volatility: ŸÜŸàÿ≥ÿßŸÜ ÿØÿßÿ±ÿß€å€å Ÿæÿß€åŸá (Ÿæ€åÿ¥‚ÄåŸÅÿ±ÿ∂ 30 ÿØÿ±ÿµÿØ)
        """
        return calculator.calculate(
            option_type=self.option_type,
            spot=self.spot_price,
            strike=self.strike_price,
            time_to_expiry=self.time_to_expiry_days / 365,
            risk_free_rate=risk_free_rate,
            volatility=volatility
        )
        
    @abstractmethod
    def get_payoff(self, spot_price: Optional[float] = None) -> float:
        ...

    @abstractmethod
    def get_break_even_price(self) -> float:
        ...
```

- **File**: `stock_option.py`
  - üìç Path: `core/entities/option/stock_option.py`

```python
# core/entities/option/stock_option.py

from dataclasses import dataclass
from datetime import datetime
from typing import Optional
from core.entities.option.option import AbstractOption
from core.entities.asset.stock_asset import StockAsset
from core.entities.enum.enums import OptionType


@dataclass
class StockOption(AbstractOption):
    underlying_asset: StockAsset

    def calculate_raw_payoff(self, spot_price: float) -> float:
        if self.option_type == OptionType.CALL:
            return max(0.0, spot_price - self.strike_price)
        return max(0.0, self.strike_price - spot_price)

    def get_payoff(self, spot_price: Optional[float] = None) -> float:
        spot = spot_price or self.spot_price
        raw_payoff_per_unit = self.calculate_raw_payoff(spot)

        # ‚úÖ Ÿáÿ≤€åŸÜŸá‚ÄåŸáÿß ÿ®ÿ±ÿß€å €å⁄© Ÿàÿßÿ≠ÿØ
        fee_per_unit = (self.transaction_fee / 100 * spot) if self.transaction_fee else 0
        settle_per_unit = (self.settlement_cost / 100 * spot) if self.settlement_cost else 0



        total_cost_per_unit = self.premium + fee_per_unit + settle_per_unit
        return (raw_payoff_per_unit - total_cost_per_unit) * self.contract_size

    def get_break_even_price(self) -> float:
        fee = (self.transaction_fee / 100 * self.strike_price) if self.transaction_fee else 0
        settle = (self.settlement_cost / 100 * self.strike_price) if self.settlement_cost else 0
        return self.strike_price + self.premium + fee + settle
```


## üóÇÔ∏è Layer: Value Objects
üìÇ Path: `core/entities/option/value_objects`

- **File**: `greeks.py`
  - üìç Path: `core/entities/option/value_objects/greeks.py`

```python
from dataclasses import dataclass

@dataclass(frozen=True)
class OptionGreeks:
    delta: float
    gamma: float
    theta: float
    vega: float
    rho: float

    def __str__(self):
        return f"Œî: {self.delta:.4f}, Œì: {self.gamma:.4f}, Œò: {self.theta:.4f}, ùúà: {self.vega:.4f}, œÅ: {self.rho:.4f}"
```

- **File**: `__init__.py`
  - üìç Path: `core/__init__.py`

```python
```


## üóÇÔ∏è Layer: Infrastructure
üìÇ Path: `infrastructure`


## üóÇÔ∏è Layer: Data Providers
üìÇ Path: `infrastructure/data_providers`

- **File**: `__init__.py`
  - üìç Path: `infrastructure/data_providers/__init__.py`

```python
```


## üóÇÔ∏è Layer: Db
üìÇ Path: `infrastructure/db`

- **File**: `__init__.py`
  - üìç Path: `infrastructure/db/__init__.py`

```python
```

- **File**: `__init__.py`
  - üìç Path: `infrastructure/__init__.py`

```python
```


## üóÇÔ∏è Layer: Notifiers
üìÇ Path: `infrastructure/notifiers`

- **File**: `__init__.py`
  - üìç Path: `infrastructure/notifiers/__init__.py`

```python
```

- **File**: `__init__.py`
  - üìç Path: `__init__.py`

```python
```


## üóÇÔ∏è Layer: Interfaces
üìÇ Path: `interfaces`


## üóÇÔ∏è Layer: Api
üìÇ Path: `interfaces/api`

- **File**: `__init__.py`
  - üìç Path: `interfaces/api/__init__.py`

```python
```


## üóÇÔ∏è Layer: Cli
üìÇ Path: `interfaces/cli`

- **File**: `__init__.py`
  - üìç Path: `interfaces/cli/__init__.py`

```python
```

- **File**: `__init__.py`
  - üìç Path: `interfaces/__init__.py`

```python
```


## üóÇÔ∏è Layer: Scheduler
üìÇ Path: `interfaces/scheduler`

- **File**: `__init__.py`
  - üìç Path: `interfaces/scheduler/__init__.py`

```python
```

- **File**: `main.py`
  - üìç Path: `main.py`

```python
```


## üóÇÔ∏è Layer: Notebooks
üìÇ Path: `notebooks`


## üóÇÔ∏è Layer: Entities
üìÇ Path: `notebooks/entities`

- **File**: `asset.ipynb`
  - üìç Path: `notebooks/entities/asset.ipynb`

```python
{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "f73bf675",
   "metadata": {},
   "source": [
    "# Call Packages"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "1d52dacd",
   "metadata": {},
   "outputs": [],
   "source": [
    "import os\n",
    "os.chdir('/home/sajad/All Project/Clean Architecture Python/Project/src/crypto_option_arbitrage')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6f69984b",
   "metadata": {},
   "outputs": [],
   "source": [
    "from core.entities.enum.enums import Market\n",
    "# Stock Crypto Etf\n",
    "from core.entities.asset.stock_asset import StockAsset\n",
    "from core.entities.asset.crypto_asset import CryptoAsset\n",
    "from core.entities.asset.etf_asset import ETFAsset\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2551f2bc",
   "metadata": {},
   "source": [
    "# Strock Asset Class\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7d8401bf",
   "metadata": {},
   "source": [
    "## Create Instance"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "6244327e",
   "metadata": {},
   "outputs": [],
   "source": [
    "StockInstanse = StockAsset(\n",
    "        name=\"ŸÅŸàŸÑÿßÿØ ŸÖÿ®ÿßÿ±⁄©Ÿá\",\n",
    "        symbol=\"ŸÅŸàŸÑÿßÿØ\",\n",
    "        isin=\"IRO1FOLD0001\",\n",
    "        market=Market.TSE_FIRST,\n",
    "        last_price=5000,\n",
    "        close_price=5100,\n",
    "        previous_price=4950,\n",
    "        ask_price=5150,\n",
    "        bid_price=5050\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4c4ba6f4",
   "metadata": {},
   "source": [
    "## Call Variable and Methods"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "0d2dadea",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      " Info name     :ŸÅŸàŸÑÿßÿØ ŸÖÿ®ÿßÿ±⁄©Ÿá\n",
      " Market        :ÿ®Ÿàÿ±ÿ≥ - ÿ®ÿßÿ≤ÿßÿ± ÿßŸàŸÑ\n",
      " Asset Class   :Stock\n",
      " Market time   :('09:00', '12:30')\n",
      " Range Price   :5.0\n",
      " TC            :1.5\n",
      " is open ?     :False\n"
     ]
    }
   ],
   "source": [
    "print(rf' Info name     :{StockInstanse.name}')\n",
    "print(rf' Market        :{StockInstanse.market}')\n",
    "print(rf' Asset Class   :{StockInstanse.asset_class}')\n",
    "\n",
    "print(rf' Market time   :{StockInstanse.trading_hours}')\n",
    "print(rf' Range Price   :{StockInstanse.get_price_limit()}')\n",
    "print(rf' TC            :{StockInstanse.get_transaction_fee()}')\n",
    "print(rf' is open ?     :{StockInstanse.is_trading_now()}')\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "71797f2f",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'name': 'ŸÅŸàŸÑÿßÿØ ŸÖÿ®ÿßÿ±⁄©Ÿá',\n",
       " 'symbol': 'ŸÅŸàŸÑÿßÿØ',\n",
       " 'isin': 'IRO1FOLD0001',\n",
       " 'asset_class': <AssetClass.STOCK: 'Stock'>,\n",
       " 'market': <Market.TSE_FIRST: 'ÿ®Ÿàÿ±ÿ≥ - ÿ®ÿßÿ≤ÿßÿ± ÿßŸàŸÑ'>,\n",
       " 'last_price': 5000,\n",
       " 'close_price': 5100,\n",
       " 'previous_price': 4950,\n",
       " 'settlement_days': 2,\n",
       " 'trading_hours': ('09:00', '12:30'),\n",
       " 'ask_price': 5150,\n",
       " 'bid_price': 5050}"
      ]
     },
     "execution_count": 5,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "StockInstanse.__dict__"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "65193fe8",
   "metadata": {},
   "source": [
    "## Method resolution order (MRO)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "f38c52af",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Help on StockAsset in module core.entities.asset.stock_asset object:\n",
      "\n",
      "class StockAsset(core.entities.asset.asset.AbstractAsset)\n",
      " |  StockAsset(name: str, symbol: str, isin: str, market: core.entities.enum.enums.Market, last_price: float, close_price: float, previous_price: float, ask_price: float = None, bid_price: float = None)\n",
      " |  \n",
      " |  Method resolution order:\n",
      " |      StockAsset\n",
      " |      core.entities.asset.asset.AbstractAsset\n",
      " |      abc.ABC\n",
      " |      builtins.object\n",
      " |  \n",
      " |  Methods defined here:\n",
      " |  \n",
      " |  __init__(self, name: str, symbol: str, isin: str, market: core.entities.enum.enums.Market, last_price: float, close_price: float, previous_price: float, ask_price: float = None, bid_price: float = None)\n",
      " |      Initialize self.  See help(type(self)) for accurate signature.\n",
      " |  \n",
      " |  ----------------------------------------------------------------------\n",
      " |  Data and other attributes defined here:\n",
      " |  \n",
      " |  __abstractmethods__ = frozenset()\n",
      " |  \n",
      " |  __annotations__ = {}\n",
      " |  \n",
      " |  ----------------------------------------------------------------------\n",
      " |  Methods inherited from core.entities.asset.asset.AbstractAsset:\n",
      " |  \n",
      " |  __eq__(self, other)\n",
      " |      Return self==value.\n",
      " |  \n",
      " |  __repr__(self)\n",
      " |      Return repr(self).\n",
      " |  \n",
      " |  get_price_limit(self) -> float\n",
      " |      ÿØÿßŸÖŸÜŸá ŸÜŸàÿ≥ÿßŸÜ ŸÖÿ¨ÿßÿ≤ ÿ®ÿ±ÿß€å ÿ®ÿßÿ≤ÿßÿ± ÿØÿßÿ±ÿß€å€å (ÿ®ÿ± ÿ≠ÿ≥ÿ® ÿØÿ±ÿµÿØ)\n",
      " |  \n",
      " |  get_spread(self) -> Optional[float]\n",
      " |      ÿßÿÆÿ™ŸÑÿßŸÅ ŸÇ€åŸÖÿ™ ÿÆÿ±€åÿØ Ÿà ŸÅÿ±Ÿàÿ¥ (ask - bid)\n",
      " |  \n",
      " |  get_transaction_fee(self) -> float\n",
      " |      ⁄©ÿßÿ±ŸÖÿ≤ÿØ ŸÖÿπÿßŸÖŸÑŸá ÿØÿßÿ±ÿß€å€å (ÿ®ÿ± ÿ≠ÿ≥ÿ® ÿØÿ±ÿµÿØ)\n",
      " |  \n",
      " |  has_price_limit_breach(self, current_price: float) -> bool\n",
      " |  \n",
      " |  is_trading_now(self, current_time: Optional[datetime.datetime] = None) -> bool\n",
      " |      ÿ®ÿ±ÿ±ÿ≥€å ŸÅÿπÿßŸÑ ÿ®ŸàÿØŸÜ ÿ®ÿßÿ≤ÿßÿ± ÿØÿ± ŸÑÿ≠ÿ∏Ÿá ŸÅÿπŸÑ€å\n",
      " |  \n",
      " |  is_valid(self) -> bool\n",
      " |      ÿ®ÿ±ÿ±ÿ≥€å ÿßÿπÿ™ÿ®ÿßÿ± ÿßŸàŸÑ€åŸá ÿØÿßÿ±ÿß€å€å\n",
      " |  \n",
      " |  ----------------------------------------------------------------------\n",
      " |  Data descriptors inherited from core.entities.asset.asset.AbstractAsset:\n",
      " |  \n",
      " |  __dict__\n",
      " |      dictionary for instance variables (if defined)\n",
      " |  \n",
      " |  __weakref__\n",
      " |      list of weak references to the object (if defined)\n",
      " |  \n",
      " |  ----------------------------------------------------------------------\n",
      " |  Data and other attributes inherited from core.entities.asset.asset.AbstractAsset:\n",
      " |  \n",
      " |  __dataclass_fields__ = {'ask_price': Field(name='ask_price',type=typin...\n",
      " |  \n",
      " |  __dataclass_params__ = _DataclassParams(init=True,repr=True,eq=True,or...\n",
      " |  \n",
      " |  __hash__ = None\n",
      " |  \n",
      " |  __match_args__ = ('name', 'symbol', 'isin', 'asset_class', 'market', '...\n",
      " |  \n",
      " |  ask_price = None\n",
      " |  \n",
      " |  bid_price = None\n",
      "\n"
     ]
    }
   ],
   "source": [
    "help(StockInstanse)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8962c998",
   "metadata": {},
   "source": [
    "# Crypto"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "10444e33",
   "metadata": {},
   "source": [
    "## Create Instance"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "369b59c0",
   "metadata": {},
   "outputs": [],
   "source": [
    "btc = CryptoAsset(\n",
    "    name=\"Bitcoin\",\n",
    "    symbol=\"BTC\",\n",
    "    market=Market.GLOBAL,\n",
    "    last_price=58320,\n",
    "    close_price=58000,\n",
    "    previous_price=57000,\n",
    "    ask_price=58350,\n",
    "    bid_price=58250\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "f03abf77",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "‚úÖ CryptoAsset ÿ≥ÿßÿÆÿ™Ÿá ÿ¥ÿØ: CryptoAsset(name='Bitcoin', symbol='BTC', isin=None, asset_class=<AssetClass.CRYPTO: 'Crypto'>, market=<Market.GLOBAL: 'ÿ®ÿßÿ≤ÿßÿ± ÿ¨ŸáÿßŸÜ€å (⁄©ÿ±€åŸæÿ™Ÿà / ÿÆÿßÿ±ÿ¨€å)'>, last_price=58320, close_price=58000, previous_price=57000, settlement_days=0, trading_hours=('00:00', '23:59'), ask_price=58350, bid_price=58250)\n",
      "‚úÖ ÿØÿßŸÖŸÜŸá ŸÜŸàÿ≥ÿßŸÜ: 0.0\n",
      "‚úÖ ⁄©ÿßÿ±ŸÖÿ≤ÿØ ŸÖÿπÿßŸÖŸÑŸá: 0.2\n",
      "‚úÖ ÿßÿÆÿ™ŸÑÿßŸÅ ŸÇ€åŸÖÿ™: 100\n",
      "‚úÖ ÿßÿπÿ™ÿ®ÿßÿ± ŸÇ€åŸÖÿ™‚ÄåŸáÿß: True\n",
      "‚úÖ ŸÅÿπÿßŸÑ ÿ®ŸàÿØŸÜ ÿ®ÿßÿ≤ÿßÿ± ÿß⁄©ŸÜŸàŸÜ: True\n",
      "‚úÖ ÿ≥ÿßÿπÿ™ ÿ®ÿßÿ≤ ÿ®ŸàÿØŸÜ ÿ®ÿßÿ≤ÿßÿ± : ('00:00', '23:59')\n"
     ]
    }
   ],
   "source": [
    "print(\"‚úÖ CryptoAsset ÿ≥ÿßÿÆÿ™Ÿá ÿ¥ÿØ:\", btc)\n",
    "\n",
    "# Cell 4: ÿ®ÿ±ÿ±ÿ≥€å ŸÖÿ™ÿØŸáÿß€å ŸÖÿ±ÿ®Ÿàÿ∑ ÿ®Ÿá CryptoAsset\n",
    "print(\"‚úÖ ÿØÿßŸÖŸÜŸá ŸÜŸàÿ≥ÿßŸÜ:\", btc.get_price_limit())\n",
    "print(\"‚úÖ ⁄©ÿßÿ±ŸÖÿ≤ÿØ ŸÖÿπÿßŸÖŸÑŸá:\", btc.get_transaction_fee())\n",
    "print(\"‚úÖ ÿßÿÆÿ™ŸÑÿßŸÅ ŸÇ€åŸÖÿ™:\", btc.get_spread())\n",
    "print(\"‚úÖ ÿßÿπÿ™ÿ®ÿßÿ± ŸÇ€åŸÖÿ™‚ÄåŸáÿß:\", btc.is_valid())\n",
    "print(\"‚úÖ ŸÅÿπÿßŸÑ ÿ®ŸàÿØŸÜ ÿ®ÿßÿ≤ÿßÿ± ÿß⁄©ŸÜŸàŸÜ:\", btc.is_trading_now())\n",
    "print(\"‚úÖ ÿ≥ÿßÿπÿ™ ÿ®ÿßÿ≤ ÿ®ŸàÿØŸÜ ÿ®ÿßÿ≤ÿßÿ± :\", btc.trading_hours)\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "770ab0e5",
   "metadata": {},
   "outputs": [],
   "source": [
    "etf = ETFAsset(\n",
    "    name=\"ÿµŸÜÿØŸàŸÇ ÿ¥ÿßÿÆÿµ€å ⁄©ÿßÿ±ÿ¢ŸÅÿ±€åŸÜ\",\n",
    "    symbol=\"⁄©ÿßÿ±ÿ¢ŸÅÿ±€åŸÜ\",\n",
    "    isin=\"IR1234567890\",\n",
    "    market=Market.IFB_THIRD,\n",
    "    last_price=21500,\n",
    "    close_price=21200,\n",
    "    previous_price=21000,\n",
    "    ask_price=21600,\n",
    "    bid_price=21400\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "376cb174",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "‚úÖ ETFAsset ÿ≥ÿßÿÆÿ™Ÿá ÿ¥ÿØ: ETFAsset(name='ÿµŸÜÿØŸàŸÇ ÿ¥ÿßÿÆÿµ€å ⁄©ÿßÿ±ÿ¢ŸÅÿ±€åŸÜ', symbol='⁄©ÿßÿ±ÿ¢ŸÅÿ±€åŸÜ', isin='IR1234567890', asset_class=<AssetClass.ETF: 'ETF'>, market=<Market.IFB_THIRD: 'ŸÅÿ±ÿßÿ®Ÿàÿ±ÿ≥ - ÿ®ÿßÿ≤ÿßÿ± ÿ≥ŸàŸÖ'>, last_price=21500, close_price=21200, previous_price=21000, settlement_days=2, trading_hours=('09:00', '15:00'), ask_price=21600, bid_price=21400)\n",
      "‚úÖ ÿØÿßŸÖŸÜŸá ŸÜŸàÿ≥ÿßŸÜ: 5.0\n",
      "‚úÖ ⁄©ÿßÿ±ŸÖÿ≤ÿØ ŸÖÿπÿßŸÖŸÑŸá: 0.5\n",
      "‚úÖ ÿßÿÆÿ™ŸÑÿßŸÅ ŸÇ€åŸÖÿ™: 200\n",
      "‚úÖ ÿßÿπÿ™ÿ®ÿßÿ± ŸÇ€åŸÖÿ™‚ÄåŸáÿß: True\n",
      "‚úÖ ŸÅÿπÿßŸÑ ÿ®ŸàÿØŸÜ ÿ®ÿßÿ≤ÿßÿ± ÿß⁄©ŸÜŸàŸÜ: False\n",
      "‚úÖ ÿ≥ÿßÿπÿ™ ÿ®ÿßÿ≤ ÿ®ŸàÿØŸÜ ÿ®ÿßÿ≤ÿßÿ± : ('09:00', '15:00')\n"
     ]
    }
   ],
   "source": [
    "print(\"\\n‚úÖ ETFAsset ÿ≥ÿßÿÆÿ™Ÿá ÿ¥ÿØ:\", etf)\n",
    "\n",
    "# Cell 6: ÿ®ÿ±ÿ±ÿ≥€å ŸÖÿ™ÿØŸáÿß€å ŸÖÿ±ÿ®Ÿàÿ∑ ÿ®Ÿá ETFAsset\n",
    "print(\"‚úÖ ÿØÿßŸÖŸÜŸá ŸÜŸàÿ≥ÿßŸÜ:\", etf.get_price_limit())\n",
    "print(\"‚úÖ ⁄©ÿßÿ±ŸÖÿ≤ÿØ ŸÖÿπÿßŸÖŸÑŸá:\", etf.get_transaction_fee())\n",
    "print(\"‚úÖ ÿßÿÆÿ™ŸÑÿßŸÅ ŸÇ€åŸÖÿ™:\", etf.get_spread())\n",
    "print(\"‚úÖ ÿßÿπÿ™ÿ®ÿßÿ± ŸÇ€åŸÖÿ™‚ÄåŸáÿß:\", etf.is_valid())\n",
    "print(\"‚úÖ ŸÅÿπÿßŸÑ ÿ®ŸàÿØŸÜ ÿ®ÿßÿ≤ÿßÿ± ÿß⁄©ŸÜŸàŸÜ:\", etf.is_trading_now())\n",
    "print(\"‚úÖ ÿ≥ÿßÿπÿ™ ÿ®ÿßÿ≤ ÿ®ŸàÿØŸÜ ÿ®ÿßÿ≤ÿßÿ± :\", etf.trading_hours)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c648b862",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
```

- **File**: `option.ipynb`
  - üìç Path: `notebooks/entities/option.ipynb`

```python
{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "63c1d4ed",
   "metadata": {},
   "source": [
    "# Option"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1fb6f81c",
   "metadata": {},
   "source": [
    "## Import Packages"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "88a89624",
   "metadata": {},
   "outputs": [],
   "source": [
    "import os\n",
    "os.chdir('/home/sajad/All Project/Clean Architecture Python/Project/src/crypto_option_arbitrage')\n",
    "from datetime import datetime, timedelta\n",
    "from core.entities.enum.enums import Market, OptionType, ContractStatus\n",
    "from core.config.market_rules import RISK_FREE_RATE\n",
    "from core.entities.option.value_objects.greeks import OptionGreeks\n",
    "from core.entities.option.calculators.greeks.black_scholes import BlackScholesGreekCalculator\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4296dcc8",
   "metadata": {},
   "source": [
    "## Stock Option"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "aba6b064",
   "metadata": {},
   "outputs": [],
   "source": [
    "from core.entities.asset.stock_asset import StockAsset\n",
    "from core.entities.option.stock_option import StockOption"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "9f4b9ff6",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Cell 3: ÿ≥ÿßÿÆÿ™ ÿØÿßÿ±ÿß€å€å Ÿæÿß€åŸá\n",
    "stock = StockAsset(\n",
    "    name=\"ŸÅŸàŸÑÿßÿØ ŸÖÿ®ÿßÿ±⁄©Ÿá\",\n",
    "    symbol=\"FOLD\",\n",
    "    isin=\"IR1234567890\",\n",
    "    market=Market.TSE_FIRST,\n",
    "    last_price=1100,\n",
    "    close_price=1000,\n",
    "    previous_price=990,\n",
    "    ask_price=1110,\n",
    "    bid_price=1090,\n",
    ")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "9c9c8fab",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Cell 4: ÿ≥ÿßÿÆÿ™ ÿ¢Ÿæÿ¥ŸÜ ⁄©ÿßŸÑ\n",
    "stock_option = StockOption(\n",
    "    contract_name=\"FOLD_C_1000\",\n",
    "    option_type=OptionType.CALL,\n",
    "    strike_price=1000,\n",
    "    premium=50,\n",
    "    expiry=datetime.utcnow() + timedelta(days=10),\n",
    "    underlying_asset=stock,\n",
    "    ask=55,\n",
    "    bid=45,\n",
    "    transaction_fee=2.0,\n",
    "    settlement_cost=1.0\n",
    ")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "85da6bf4",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Spot Price: 1100\n",
      "Time to Expiry: 10\n",
      "Break Even: 1080.0\n",
      "Payoff: 65500.0\n",
      "Contract Status: ContractStatus.IN_THE_MONEY\n",
      "\n",
      "üìò GreekŸáÿß€å StockOption:\n",
      "Œî: 0.9800, Œì: 0.0009, Œò: -0.6647, ùúà: 0.0880, œÅ: 0.2663\n"
     ]
    }
   ],
   "source": [
    "# Cell 5: ÿ®ÿ±ÿ±ÿ≥€å ÿπŸÖŸÑ⁄©ÿ±ÿØŸáÿß\n",
    "print(\"Spot Price:\", stock_option.spot_price)\n",
    "print(\"Time to Expiry:\", stock_option.time_to_expiry_days)\n",
    "print(\"Break Even:\", stock_option.get_break_even_price())\n",
    "print(\"Payoff:\", stock_option.get_payoff(spot_price=1150))\n",
    "print(\"Contract Status:\", stock_option.contract_status)\n",
    "\n",
    "# ÿßŸÜÿ™ÿÆÿßÿ® ŸÖÿØŸÑ ŸÖÿ≠ÿßÿ≥ÿ®Ÿá ÿßÿπÿØÿßÿØ €åŸàŸÜÿßŸÜ€å ŸÖÿß⁄òŸàŸÑÿßÿ± ÿßÿ≥ÿ™\n",
    "calculator = BlackScholesGreekCalculator()\n",
    "print(\"\\nüìò GreekŸáÿß€å StockOption:\")\n",
    "print(stock_option.get_greeks(calculator=calculator))\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "30aa63ce",
   "metadata": {},
   "source": [
    "## ETF"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "c83189c1",
   "metadata": {},
   "outputs": [],
   "source": [
    "from core.entities.asset.etf_asset import ETFAsset\n",
    "from core.entities.option.etf_option import ETFOption"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "ede6a2be",
   "metadata": {},
   "outputs": [],
   "source": [
    "etf = ETFAsset(\n",
    "    name=\"ÿµŸÜÿØŸàŸÇ ÿ¥ÿßÿÆÿµ€å\",\n",
    "    symbol=\"ÿµŸÜÿØŸàŸÇ\",\n",
    "    isin=\"IR1234567890\",\n",
    "    market=Market.IFB_THIRD,\n",
    "    last_price=10200,\n",
    "    close_price=10100,\n",
    "    previous_price=10000,\n",
    "    ask_price=10250,\n",
    "    bid_price=10150\n",
    ")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "ebb31759",
   "metadata": {},
   "outputs": [],
   "source": [
    "etf_option = ETFOption(\n",
    "    contract_name=\"ETF_CALL_10500\",\n",
    "    option_type=OptionType.CALL,\n",
    "    strike_price=10500,\n",
    "    premium=200,\n",
    "    expiry=datetime.utcnow() + timedelta(days=10),\n",
    "    underlying_asset=etf,\n",
    "    ask=210,\n",
    "    bid=190,\n",
    "    transaction_fee=0.5,\n",
    "    settlement_cost=1.0,\n",
    "    benchmark_index=\"S&P 500\"\n",
    ")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7d8c1e97",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "üìà Spot Price: 10200\n",
      "üïí Time to Expiry: 10\n",
      "üìä Break Even Price: 10857.5\n",
      "üí∞ Payoff at 11000: 135000.0\n",
      "üìâ Contract Status: OUT_OF_THE_MONEY\n",
      "üîÅ Is Liquid: True\n",
      "üìâ NAV Deviation? True\n",
      "üìâ Deviation Value: 0.04081632653061224\n",
      "\n",
      "üìò GreekŸáÿß€å StockOption:\n",
      "Œî: 0.3269, Œì: 0.0007, Œò: -10.9050, ùúà: 6.0907, œÅ: 0.8845\n"
     ]
    }
   ],
   "source": [
    "\n",
    "print(\"üìà Spot Price:\", etf_option.spot_price)\n",
    "print(\"üïí Time to Expiry:\", etf_option.time_to_expiry_days)\n",
    "print(\"üìä Break Even Price:\", etf_option.get_break_even_price())\n",
    "print(\"üí∞ Payoff at 11000:\", etf_option.get_payoff(11000))\n",
    "print(\"üìâ Contract Status:\", etf_option.contract_status.name)\n",
    "print(\"üîÅ Is Liquid:\", etf_option.is_liquid())\n",
    "print(\"üìâ NAV Deviation?\", etf_option.has_nav_deviation(9800))\n",
    "print(\"üìâ Deviation Value:\", etf_option.nav_deviation)\n",
    "# ÿßŸÜÿ™ÿÆÿßÿ® ŸÖÿØŸÑ ŸÖÿ≠ÿßÿ≥ÿ®Ÿá ÿßÿπÿØÿßÿØ €åŸàŸÜÿßŸÜ€å ŸÖÿß⁄òŸàŸÑÿßÿ± ÿßÿ≥ÿ™\n",
    "calculator = BlackScholesGreekCalculator()\n",
    "print(\"\\nüìò GreekŸáÿß€å etf_option:\")\n",
    "print(etf_option.get_greeks(calculator=calculator))\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4c664b33",
   "metadata": {},
   "source": [
    "## Leverage ETF"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "16ab23cd",
   "metadata": {},
   "outputs": [],
   "source": [
    "from core.entities.asset.leverage_etf_asset import LeverageETFAsset\n",
    "from core.entities.option.leverage_etf_option import LeverageETFOption"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "9f24451f",
   "metadata": {},
   "outputs": [],
   "source": [
    "etf_asset = LeverageETFAsset(\n",
    "    name=\"ŸÜŸÖŸàŸÜŸá ÿßŸáÿ±ŸÖ€å\",\n",
    "    symbol=\"LETF\",\n",
    "    isin=\"IR000000LETF\",\n",
    "    market=Market.IFB_SECOND,\n",
    "    last_price=9100,\n",
    "    close_price=9000,\n",
    "    previous_price=8800,\n",
    "    ask_price=9150,\n",
    "    bid_price=9050,\n",
    "    leverage_ratio=2.0\n",
    ")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "690b1d25",
   "metadata": {},
   "outputs": [],
   "source": [
    "lev_etf_option = LeverageETFOption(\n",
    "    contract_name=\"LETF_CALL_8800\",\n",
    "    option_type=OptionType.CALL,\n",
    "    strike_price=8800,\n",
    "    premium=250,\n",
    "    expiry=datetime.utcnow() + timedelta(days=20),\n",
    "    underlying_asset=etf_asset,\n",
    "    ask=260,\n",
    "    bid=240,\n",
    "    contract_size=1000,\n",
    "    transaction_fee=0.5,     # 0.5 ÿØÿ±ÿµÿØ\n",
    "    settlement_cost=1.0      # 1 ÿØÿ±ÿµÿØ\n",
    ")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "28198a74",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "üìò Contract Info\n",
      "ŸÜÿßŸÖ: LETF_CALL_8800\n",
      "ŸÜŸàÿπ: OptionType.CALL\n",
      "ŸÇ€åŸÖÿ™ ÿßÿπŸÖÿßŸÑ: 8800\n",
      "Ÿæÿ±€åŸÖ€åŸàŸÖ: 250\n",
      "----------------------------------------\n",
      "‚è≥ ÿ≤ŸÖÿßŸÜ ÿ™ÿß ÿ≥ÿ±ÿ±ÿ≥€åÿØ: 20 ÿ±Ÿàÿ≤\n",
      "üìä Ÿàÿ∂ÿπ€åÿ™ ŸÇÿ±ÿßÿ±ÿØÿßÿØ: IN_THE_MONEY\n",
      "üí∞ ŸÇ€åŸÖÿ™ ÿ≥ÿ± ÿ®Ÿá ÿ≥ÿ± (Break-even): 9182.0\n",
      "üí∏ Payoff ÿØÿ± spot=9000: 15000.0\n",
      "üí∏ Payoff ÿØÿ± spot=8500: -377500.0\n",
      "üìâ ÿ≠ÿØÿß⁄©ÿ´ÿ± ÿ≤€åÿßŸÜ: 386500.0\n",
      "üìà ÿ≠ÿØÿß⁄©ÿ´ÿ± ÿ≥ŸàÿØ ÿØÿ± max_spot=9500: 1013500.0\n",
      "\n",
      "üìò GreekŸáÿß€å lev_etf_option:\n",
      "Œî: 0.7481, Œì: 0.0005, Œò: -8.5558, ùúà: 6.7963, œÅ: 3.4587\n"
     ]
    }
   ],
   "source": [
    "\n",
    "# 3Ô∏è‚É£ ⁄ÜÿßŸæ ÿßÿ∑ŸÑÿßÿπÿßÿ™ ÿßŸàŸÑ€åŸá\n",
    "print(\"üìò Contract Info\")\n",
    "print(\"ŸÜÿßŸÖ:\", lev_etf_option.contract_name)\n",
    "print(\"ŸÜŸàÿπ:\", lev_etf_option.option_type)\n",
    "print(\"ŸÇ€åŸÖÿ™ ÿßÿπŸÖÿßŸÑ:\", lev_etf_option.strike_price)\n",
    "print(\"Ÿæÿ±€åŸÖ€åŸàŸÖ:\", lev_etf_option.premium)\n",
    "print(\"-\" * 40)\n",
    "\n",
    "# 4Ô∏è‚É£ ÿ≤ŸÖÿßŸÜ ÿ™ÿß ÿ≥ÿ±ÿ±ÿ≥€åÿØ\n",
    "print(\"‚è≥ ÿ≤ŸÖÿßŸÜ ÿ™ÿß ÿ≥ÿ±ÿ±ÿ≥€åÿØ:\", lev_etf_option.time_to_expiry_days, \"ÿ±Ÿàÿ≤\")\n",
    "\n",
    "# 5Ô∏è‚É£ Ÿàÿ∂ÿπ€åÿ™ ŸÇÿ±ÿßÿ±ÿØÿßÿØ\n",
    "print(\"üìä Ÿàÿ∂ÿπ€åÿ™ ŸÇÿ±ÿßÿ±ÿØÿßÿØ:\", lev_etf_option.contract_status.name)\n",
    "\n",
    "# 6Ô∏è‚É£ ŸÖÿ≠ÿßÿ≥ÿ®Ÿá Break-even\n",
    "print(\"üí∞ ŸÇ€åŸÖÿ™ ÿ≥ÿ± ÿ®Ÿá ÿ≥ÿ± (Break-even):\", lev_etf_option.get_break_even_price())\n",
    "\n",
    "# 7Ô∏è‚É£ ŸÖÿ≠ÿßÿ≥ÿ®Ÿá Payoff ÿ®ÿ±ÿß€å ŸÇ€åŸÖÿ™ ÿßÿ≥Ÿæÿßÿ™ ŸÖÿÆÿ™ŸÑŸÅ\n",
    "print(\"üí∏ Payoff ÿØÿ± spot=9000:\", lev_etf_option.get_payoff(spot_price=9000))\n",
    "print(\"üí∏ Payoff ÿØÿ± spot=8500:\", lev_etf_option.get_payoff(spot_price=8500))\n",
    "\n",
    "# 8Ô∏è‚É£ ÿ≠ÿØÿß⁄©ÿ´ÿ± ÿ≤€åÿßŸÜ\n",
    "print(\"üìâ ÿ≠ÿØÿß⁄©ÿ´ÿ± ÿ≤€åÿßŸÜ:\", lev_etf_option.get_max_loss())\n",
    "\n",
    "# 9Ô∏è‚É£ ÿ≠ÿØÿß⁄©ÿ´ÿ± ÿ≥ŸàÿØ ÿØÿ± ÿ≥ŸÇŸÅ ŸÅÿ±ÿ∂€å 9500\n",
    "print(\"üìà ÿ≠ÿØÿß⁄©ÿ´ÿ± ÿ≥ŸàÿØ ÿØÿ± max_spot=9500:\", lev_etf_option.get_max_gain(max_spot=9500))\n",
    "\n",
    "# ÿßŸÜÿ™ÿÆÿßÿ® ŸÖÿØŸÑ ŸÖÿ≠ÿßÿ≥ÿ®Ÿá ÿßÿπÿØÿßÿØ €åŸàŸÜÿßŸÜ€å ŸÖÿß⁄òŸàŸÑÿßÿ± ÿßÿ≥ÿ™\n",
    "calculator = BlackScholesGreekCalculator()\n",
    "print(\"\\nüìò GreekŸáÿß€å lev_etf_option:\")\n",
    "print(lev_etf_option.get_greeks(calculator=calculator))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b6ba15aa",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
```

- **File**: `project_structure_documentation.md`
  - üìç Path: `project_structure_documentation.md`

```python
```


## üóÇÔ∏è Layer: Tests
üìÇ Path: `tests`


## üóÇÔ∏è Layer: Core
üìÇ Path: `tests/core`


## üóÇÔ∏è Layer: Entities
üìÇ Path: `tests/core/entities`


## üóÇÔ∏è Layer: Asset
üìÇ Path: `tests/core/entities/asset`

- **File**: `test_crypto_asset.py`
  - üìç Path: `tests/core/entities/asset/test_crypto_asset.py`

```python
# tests/core/entities/test_crypto_asset.py

import pytest
from datetime import datetime
from core.entities.asset.crypto_asset import CryptoAsset
from core.entities.enum.enums import Market

@pytest.fixture
def crypto_asset():
    return CryptoAsset(
        name="Bitcoin",
        symbol="BTC",
        market=Market.GLOBAL,
        last_price=30000.0,
        close_price=29500.0,
        previous_price=29000.0,
        ask_price=30100.0,
        bid_price=29900.0
    )

def test_is_valid(crypto_asset):
    assert crypto_asset.is_valid() is True

def test_price_limit(crypto_asset):
    assert crypto_asset.get_price_limit() == 0.0  # ⁄©ÿ±€åŸæÿ™Ÿà ÿØÿßŸÖŸÜŸá ŸÜÿØÿßÿ±ÿØ

def test_transaction_fee(crypto_asset):
    fee = crypto_asset.get_transaction_fee()
    assert fee >= 0.0

def test_spread(crypto_asset):
    assert crypto_asset.get_spread() == 30100.0 - 29900.0

def test_price_limit_breach_upper(crypto_asset):
    assert crypto_asset.has_price_limit_breach(35000.0) is False

def test_price_limit_breach_lower(crypto_asset):
    assert crypto_asset.has_price_limit_breach(25000.0) is False

def test_is_trading_now(crypto_asset):
    assert crypto_asset.is_trading_now(datetime(2025, 1, 1, 4, 0)) is True  # ÿ≥ÿßÿπÿ™ €¥ ÿµÿ®ÿ≠
    assert crypto_asset.is_trading_now(datetime(2025, 1, 1, 22, 0)) is True  # ÿ≥ÿßÿπÿ™ €≤€≤ ÿ¥ÿ®
```

- **File**: `test_etf_asset.py`
  - üìç Path: `tests/core/entities/asset/test_etf_asset.py`

```python
import pytest
from core.entities.enum.enums import AssetClass, Market
from core.entities.asset.etf_asset import ETFAsset
from core.config.market_rules import MARKET_PRICE_LIMITS
from core.config.asset_rules import ASSET_TRANSACTION_FEES


def test_etf_asset_basic_behavior():
    asset = ETFAsset(
        name="ÿØÿßÿ±ÿß €å⁄©ŸÖ",
        symbol="ÿØÿßÿ±ÿß",
        isin="IR00DARAYK01",
        market=Market.TSE_FIRST,
        last_price=12300,
        close_price=12200,
        previous_price=12000,
        ask_price=12400,
        bid_price=12100
    )

    assert asset.asset_class == AssetClass.ETF
    assert asset.symbol == "ÿØÿßÿ±ÿß"
    assert asset.get_transaction_fee() == ASSET_TRANSACTION_FEES[AssetClass.ETF]
    assert asset.get_price_limit() == MARKET_PRICE_LIMITS[Market.TSE_FIRST]
    assert asset.get_spread() == 300


def test_etf_asset_validity():
    asset = ETFAsset(
        name="ÿØÿßÿ±ÿß €å⁄©ŸÖ",
        symbol="ÿØÿßÿ±ÿß",
        isin="IR00DARAYK01",
        market=Market.TSE_FIRST,
        last_price=12300,
        close_price=12200,
        previous_price=12000
    )

    assert asset.is_valid() is True
```

- **File**: `test_leverage_etf_asset.py`
  - üìç Path: `tests/core/entities/asset/test_leverage_etf_asset.py`

```python
# test_leverage_etf_asset.py
import pytest
from core.entities.asset.leverage_etf_asset import LeverageETFAsset
from core.entities.enum.enums import AssetClass, Market

@pytest.fixture
def leverage_etf_asset():
    return LeverageETFAsset(
        name="Leveraged Fund X",
        symbol="LEFX",
        isin="IR1234567890",
        market=Market.TSE_SECOND,  # ÿ®ÿßÿ≤ÿßÿ± ŸÅÿ±ÿπ€å ÿ®Ÿàÿ±ÿ≥
        last_price=10800.0,
        close_price=11000.0,
        previous_price=11200.0,
        ask_price=10900.0,
        bid_price=10750.0
    )

def test_basic_properties(leverage_etf_asset):
    assert leverage_etf_asset.asset_class == AssetClass.LEVERAGE_ETF
    assert leverage_etf_asset.symbol == "LEFX"
    assert leverage_etf_asset.market.name.startswith("TSE")

def test_transaction_fee(leverage_etf_asset):
    fee = leverage_etf_asset.get_transaction_fee()
    assert isinstance(fee, float)
    assert fee > 0

def test_settlement_days(leverage_etf_asset):
    assert leverage_etf_asset.settlement_days == 2  # ÿßÿ≤ ÿ±Ÿà€å config ⁄Øÿ±ŸÅÿ™Ÿá ŸÖ€å‚Äåÿ¥ŸàÿØ

def test_trading_hours(leverage_etf_asset):
    start, end = leverage_etf_asset.trading_hours
    assert start < end

def test_price_limit(leverage_etf_asset):
    limit = leverage_etf_asset.get_price_limit()
    assert limit > 0

def test_price_limit_breach_upper(leverage_etf_asset):
    # ÿ®ÿ±ÿ±ÿ≥€å ÿπÿ®Ÿàÿ± ÿßÿ≤ ÿ≥ŸÇŸÅ ŸÖÿ¨ÿßÿ≤
    current_price = 13000.0
    assert leverage_etf_asset.has_price_limit_breach(current_price) is True

def test_price_limit_breach_lower(leverage_etf_asset):
    # ÿ®ÿ±ÿ±ÿ≥€å ÿπÿ®Ÿàÿ± ÿßÿ≤ ⁄©ŸÅ ŸÖÿ¨ÿßÿ≤
    current_price = 8000.0
    assert leverage_etf_asset.has_price_limit_breach(current_price) is True

def test_spread(leverage_etf_asset):
    spread = leverage_etf_asset.get_spread()
    assert spread == 10900.0 - 10750.0
```

- **File**: `test_stock_asset.py`
  - üìç Path: `tests/core/entities/asset/test_stock_asset.py`

```python
import pytest
from core.entities.enum.enums import AssetClass, Market
from core.entities.asset.stock_asset import StockAsset
from core.config.market_rules import MARKET_PRICE_LIMITS
from core.config.asset_rules import ASSET_TRANSACTION_FEES


def test_stock_asset_properties():
    asset = StockAsset(
        name="ŸÅŸàŸÑÿßÿØ ŸÖÿ®ÿßÿ±⁄©Ÿá",
        symbol="ŸÅŸàŸÑÿßÿØ",
        isin="IRO1FOLD0001",
        market=Market.TSE_FIRST,
        last_price=5000,
        close_price=5100,
        previous_price=4950,
        ask_price=5150,
        bid_price=5050
    )

    assert asset.asset_class == AssetClass.STOCK
    assert asset.symbol == "ŸÅŸàŸÑÿßÿØ"
    assert asset.isin == "IRO1FOLD0001"
    assert asset.get_transaction_fee() == ASSET_TRANSACTION_FEES[AssetClass.STOCK]
    assert asset.get_price_limit() == MARKET_PRICE_LIMITS[Market.TSE_FIRST]
    assert asset.get_spread() == 100


def test_stock_asset_trading_status():
    asset = StockAsset(
        name="ŸÅŸàŸÑÿßÿØ ŸÖÿ®ÿßÿ±⁄©Ÿá",
        symbol="ŸÅŸàŸÑÿßÿØ",
        isin="IRO1FOLD0001",
        market=Market.TSE_FIRST,
        last_price=5000,
        close_price=5100,
        previous_price=4950
    )
    assert asset.is_valid() is True
```


## üóÇÔ∏è Layer: Option
üìÇ Path: `tests/core/entities/option`

- **File**: `test_etf_option.py`
  - üìç Path: `tests/core/entities/option/test_etf_option.py`

```python
# tests/core/entities/option/test_etf_option.py

import pytest
from datetime import datetime, timedelta

from core.entities.asset.etf_asset import ETFAsset
from core.entities.option.etf_option import ETFOption
from core.entities.enum.enums import OptionType, Market, ContractStatus
from core.entities.asset.asset import AbstractAsset


# --------------------
# Fixtures
# --------------------

@pytest.fixture
def etf_asset():
    return ETFAsset(
        name="ETF ŸÜŸÖŸàŸÜŸá",
        symbol="ETF1",
        isin="IR1234567890",
        market=Market.IFB_FIRST,
        last_price=11000.0,  # spot price
        close_price=10800.0,
        previous_price=10700.0,
        ask_price=11050.0,
        bid_price=10950.0
    )


@pytest.fixture
def etf_option(etf_asset):
    return ETFOption(
        contract_name="ETF_CALL_10500",
        option_type=OptionType.CALL,
        strike_price=10500.0,
        premium=200.0,
        expiry=datetime.utcnow() + timedelta(days=10),
        underlying_asset=etf_asset,
        ask=210.0,
        bid=190.0,
        contract_size=1000,
        transaction_fee=0.5,  # 0.5 ÿØÿ±ÿµÿØ
        settlement_cost=1.0,  # 1 ÿØÿ±ÿµÿØ
        benchmark_index="S&P 500"
    )


# --------------------
# Tests
# --------------------

def test_underlying_is_etf(etf_option):
    assert isinstance(etf_option.underlying_asset, AbstractAsset)
    assert isinstance(etf_option.underlying_asset, ETFAsset)

def test_valid_option(etf_option):
    assert etf_option.is_valid() is True

def test_time_to_expiry(etf_option):
    assert 9 <= etf_option.time_to_expiry_days <= 10

def test_contract_status(etf_option):
    assert etf_option.contract_status == ContractStatus.IN_THE_MONEY

def test_break_even_price(etf_option):
    # strike = 10500
    # premium = 200
    # fee = 0.5% * 10500 = 52.5
    # settle = 1% * 10500 = 105.0
    # total = 200 + 52.5 + 105 = 357.5
    expected = 10500 + 357.5
    assert etf_option.get_break_even_price() == pytest.approx(expected, 0.1)

def test_payoff_itm(etf_option):
    # spot = 11000 ‚Üí raw = 500/unit
    # total cost/unit = 200 + (0.5% * 11000) + (1% * 11000) = 200 + 55 + 110 = 365
    # payoff = (500 - 365) * 1000 = 135000
    expected = (500 - 365) * 1000
    assert etf_option.get_payoff(spot_price=11000) == pytest.approx(expected, 1)

def test_payoff_otm(etf_option):
    # spot = 10000 ‚Üí raw = 0
    # cost = 200 + (0.5% * 10000) + (1% * 10000) = 200 + 50 + 100 = 350
    # payoff = -350 * 1000 = -350000
    expected = -350000
    assert etf_option.get_payoff(spot_price=10000) == pytest.approx(expected, 1)

def test_is_liquid(etf_option):
    # spread = 11050 - 10950 = 100 ‚Üí 100 / 11000 = 0.009 ‚Üí < 2%
    assert etf_option.is_liquid() is True

def test_nav_deviation_check(etf_option):
    nav_price = 10600  # spot = 11000 ‚Üí deviation = ~3.77%
    assert etf_option.has_nav_deviation(nav_price) is True
    assert etf_option.nav_deviation > 0.03
```

- **File**: `test_leverage_etf_option.py`
  - üìç Path: `tests/core/entities/option/test_leverage_etf_option.py`

```python
import pytest
from datetime import datetime, timedelta

from core.entities.asset.leverage_etf_asset import LeverageETFAsset
from core.entities.option.leverage_etf_option import LeverageETFOption
from core.entities.enum.enums import OptionType, Market, ContractStatus
from core.entities.asset.asset import AbstractAsset


# --------------------
# Fixtures
# --------------------

@pytest.fixture
def leverage_etf_asset():
    return LeverageETFAsset(
        name="LETF ŸÜŸÖŸàŸÜŸá",
        symbol="LETF1",
        isin="IRLEVERAGE1234",
        market=Market.IFB_SECOND,
        last_price=9000.0,
        close_price=8800.0,
        previous_price=8700.0,
        ask_price=9050.0,
        bid_price=8950.0,
        leverage_ratio=2.0
    )


@pytest.fixture
def leverage_etf_option(leverage_etf_asset):
    return LeverageETFOption(
        contract_name="LETF_CALL_8500",
        option_type=OptionType.CALL,
        strike_price=8500.0,
        premium=300.0,
        expiry=datetime.utcnow() + timedelta(days=15),
        underlying_asset=leverage_etf_asset,
        ask=310.0,
        bid=290.0,
        contract_size=1000,
        transaction_fee=0.5,  # ÿØÿ±ÿµÿØ
        settlement_cost=1.0,  # ÿØÿ±ÿµÿØ
        leverage_ratio=2.0
    )


# --------------------
# Tests
# --------------------

def test_underlying_type(leverage_etf_option):
    assert isinstance(leverage_etf_option.underlying_asset, AbstractAsset)
    assert isinstance(leverage_etf_option.underlying_asset, LeverageETFAsset)

def test_valid_option(leverage_etf_option):
    assert leverage_etf_option.is_valid() is True

def test_time_to_expiry(leverage_etf_option):
    assert 14 <= leverage_etf_option.time_to_expiry_days <= 15

def test_contract_status(leverage_etf_option):
    assert leverage_etf_option.contract_status == ContractStatus.IN_THE_MONEY

def test_break_even_price(leverage_etf_option):
    # strike = 8500
    # premium = 300
    # fee = 0.5% * 8500 = 42.5
    # settle = 1% * 8500 = 85.0
    expected = 8500 + 300 + 42.5 + 85.0  # = 8927.5
    assert leverage_etf_option.get_break_even_price() == pytest.approx(expected, 0.1)

def test_payoff_itm(leverage_etf_option):
    # spot = 9000 ‚Üí raw = (9000 - 8500) * 2 = 1000/unit
    # cost = 300 + 0.5%*9000 + 1%*9000 = 300 + 45 + 90 = 435/unit
    # total = (1000 - 435) * 1000 = 565000
    expected = (1000 - 435) * 1000
    assert leverage_etf_option.get_payoff(spot_price=9000) == pytest.approx(expected, 1)

def test_payoff_otm(leverage_etf_option):
    # spot = 8000 ‚Üí raw = 0
    # cost = 300 + 40 + 80 = 420
    expected = -420 * 1000
    assert leverage_etf_option.get_payoff(spot_price=8000) == pytest.approx(expected, 1)

def test_max_loss(leverage_etf_option):
    # spot = 9000 ‚Üí total cost = 300 + 45 + 90 = 435 ‚Üí max loss = 435 * 1000 = 435000
    assert leverage_etf_option.get_max_loss() == pytest.approx(435000, 1)

def test_max_gain(leverage_etf_option):
    # ŸÅÿ±ÿ∂: max_spot = 9500
    # raw = (9500 - 8500) * 2 = 2000 ‚Üí total = 2,000,000 - max_loss
    expected = (2000 * 1000) - 435000
    assert leverage_etf_option.get_max_gain(max_spot=9500) == pytest.approx(expected, 1)
```

- **File**: `test_stock_option.py`
  - üìç Path: `tests/core/entities/option/test_stock_option.py`

```python
import pytest
from datetime import datetime, timedelta

from core.entities.asset.stock_asset import StockAsset
from core.entities.option.stock_option import StockOption
from core.entities.enum.enums import OptionType, Market
from core.entities.asset.asset import AbstractAsset  # ÿ®ÿ±ÿß€å ÿ®ÿ±ÿ±ÿ≥€å ÿØŸÇ€åŸÇ

# ---------------------
# Fixtures
# ---------------------

@pytest.fixture
def stock_asset():
    return StockAsset(
        name="ŸÅŸàŸÑÿßÿØ ŸÖÿ®ÿßÿ±⁄©Ÿá",
        symbol="ŸÅŸàŸÑÿßÿØ",
        isin="IRO1FOLD0001",
        market=Market.TSE_FIRST,
        last_price=150.0,
        close_price=148.0,
        previous_price=147.0,
        ask_price=151.0,
        bid_price=149.0
    )

@pytest.fixture
def stock_option_call(stock_asset):
    return StockOption(
        contract_name="EXMPL_CALL_160",
        option_type=OptionType.CALL,
        strike_price=160.0,
        premium=5.0,
        expiry=datetime.utcnow() + timedelta(days=30),
        underlying_asset=stock_asset,
        ask=6.0,
        bid=4.0,
        contract_size=1000,
        transaction_fee=5.0,  # %
        settlement_cost=1.0  # ÿ´ÿßÿ®ÿ™
    )

@pytest.fixture
def expired_option(stock_asset):
    return StockOption(
        contract_name="EXPIRED_CALL",
        option_type=OptionType.CALL,
        strike_price=160.0,
        premium=5.0,
        expiry=datetime.utcnow() - timedelta(days=1),
        underlying_asset=stock_asset,
        contract_size=1000
    )

# ---------------------
# Tests
# ---------------------

def test_underlying_type(stock_option_call):
    assert isinstance(stock_option_call.underlying_asset, AbstractAsset)

def test_valid_option(stock_option_call):
    assert stock_option_call.is_valid() is True

def test_time_to_expiry(stock_option_call):
    assert 28 <= stock_option_call.time_to_expiry_days <= 31

def test_expired_status(expired_option, stock_option_call):
    assert stock_option_call.has_expired() is False
    assert expired_option.has_expired() is True

def test_break_even_price(stock_option_call):
    # strike = 160, premium = 5, fee = 0.8, settle = 1 ‚Üí break_even = 166.8
    assert stock_option_call.get_break_even_price() == pytest.approx(166.8, 0.1)

def test_payoff_itm(stock_option_call):
    # spot = 170 ‚Üí raw = 10/unit
    # fee = 8.5, settle = 1.7 ‚Üí total cost = 15.2/unit
    expected = (10.0 - 15.2) * 1000  # = -5200
    assert stock_option_call.get_payoff(170.0) == pytest.approx(expected, 1)


def test_payoff_otm(stock_option_call):
    # spot = 150 ‚Üí raw = 0
    # fee = 7.5, settle = 1.5 ‚Üí total cost = 14.0/unit
    expected = -14.0 * 1000  # = -14000
    assert stock_option_call.get_payoff(150.0) == pytest.approx(expected, 1)


def test_contract_status(stock_option_call):
    # spot = 150 < strike = 160 ‚Üí OTM
    assert stock_option_call.contract_status.name == "OUT_OF_THE_MONEY"
```

- **File**: `__init__.py`
  - üìç Path: `tests/__init__.py`

```python
```


## üóÇÔ∏è Layer: Use Cases
üìÇ Path: `use_cases`

- **File**: `__init__.py`
  - üìç Path: `use_cases/__init__.py`

```python
```

